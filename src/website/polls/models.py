from django.db import models

# Django follows the DRY Principle: https://docs.djangoproject.com/en/3.1/misc/design-philosophies/#dry
class Question(models.Model):  # Python Inheritance.
	question_text = models.CharField(max_length=200)
	published_date = models.DateTimeField("Published date")  # "Published date" is human-readable name.

class Choice(models.Model):
	question = models.ForeignKey(Question, on_delete=models.CASCADE)  # "models.CASCADE": When the referenced object is deleted, also delete the objects that have references to it.
	choice_text = models.CharField(max_length=200)  # "CharField" requires "max_length" argument.
	votes = models.IntegerField(default=0)


"""
[NOTES]:
* Each model maps to the corresponding table (model) in the SQLite DB.
* Each property represents a DB field.
* "Database Schema": Blueprint of how the database is constructed, e.g., in SQL language.
* "python manage.py sqlmigrate polls 0001": 
* "DEFERRABLE":  It's telling the PostgreSQL to not enforce the foreign key until the end of the transaction.
* The application name is required in all DB commands.
"""

"""
[DB commands explaination]:
1. "python manage.py makemigrations polls": CUD all migration files on the "migrations" directory (module), not change the SQLite DB yet.
2. "python manage.py sqlmigrate polls 0001": Show the PostgreSQL command generated from the "migration file" generated by "python manage.py makemigrations polls".
3. "python manage.py check": Checks for any problems in the project without making migrations or touching the database.
4. "python manage.py migrate": CUD model tables in the SQLite database.
* Could verify each step of the process by using "python manage.py dbshell" and ".schema <table name>".
"""

"""
[MIGRATION TRACKING MECHANISM]:
* Django tracks which ones are applied using a special table in the SQLite DB called "django_migrations".
"""

"""
[SHOULD WE ADD MIGRATIONS DIRECTORY TO THE VERSION CONTROL SYSTEM]:
* YES. The reason that there are separate commands to make and apply migrations is because you’ll commit migrations to your version control system and ship them with your app; they not only make your development easier, they’re also usable by other developers and in production.
"""
